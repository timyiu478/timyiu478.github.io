[
  
  {
    "title": "Memory Space Management with paging",
    "url": "/posts/memory-space-management-with-paging/",
    "categories": "OS",
    "tags": "OS",
    "date": "2024-01-28 00:00:00 +0800",
    





    
    "snippet": "What is PagingPaging is another memory space management approach that dividing memory into fixed size of chuncks called pages. In contrast to segmentation, paging does not have external fragmentati...",
    "content": "What is PagingPaging is another memory space management approach that dividing memory into fixed size of chuncks called pages. In contrast to segmentation, paging does not have external fragmentation and support the abstraction of an address space effectively, regardless of how a process uses the address space since it won’t make assumptions about the way the heap and stack grow and how they are use.Address TranslationTo translate the virtual address the process generates:  We have to break the resulting virtual address into two parts:          The virtual page number (VPN) and      The offset within the page.        Using our VPN, we can now index our page table and find out which physical frame virtual page lives in.Page Table  The page table is a data structure that maps virtual addresses (or virtual page numbers) into physical addresses (physical frame numbers).  Each process has its own page table.Linear Page TableLinear Page table is an array.  VPN is an index of the array.  Each page table entry(PTE) contains PFN and other useful bits.The steps of address translation by hardware// Extract the VPN from the virtual addressVPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT// Form the address of the page-table entry (PTE)PTEAddr = PTBR + (VPN * sizeof(PTE))// Fetch the PTEPTE = AccessMemory(PTEAddr)// Check if process can access the pageif (PTE.Valid == False)    RaiseException(SEGMENTATION_FAULT)else if (CanAccess(PTE.ProtectBits) == False)    RaiseException(PROTECTION_FAULT)else    // Access is OK: form physical address and fetch itoffset = VirtualAddress &amp; OFFSET_MASKPhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offsetRegister = AccessMemory(PhysAddr)"
  },
  
  {
    "title": "Memory Segmentation",
    "url": "/posts/memory-segmentation/",
    "categories": "OS",
    "tags": "OS",
    "date": "2024-01-27 00:00:00 +0800",
    





    
    "snippet": "What is Memory Segmentation?  It allows the segments(code, stack, heap) of the address space can be stored in different physical memory locations so that we do not need to allocate the physical mem...",
    "content": "What is Memory Segmentation?  It allows the segments(code, stack, heap) of the address space can be stored in different physical memory locations so that we do not need to allocate the physical memory for the “free” segment.  Each segment has its own base/bound registers.Which segment the virtual memory address related to?Explicit Approach  we divide the address space into segments based on the first few bits of the virtual address.  the top 2 most bits represent which segment the address corresponds to.  the other bits represent the offset.// get top 2 bits of 14-bit VASegment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT// now get offsetOffset  = VirtualAddress &amp; OFFSET_MASKif (Offset &gt;= Bounds[Segment])  RaiseException(PROTECTION_FAULT)else  PhysAddr = Base[Segment] + Offset  Register = AccessMemory(PhysAddr)Implicit Approach  determines the segment by examining the address.  If the address came from the program counter (i.e., an instruction fetch), it’s in the code segment.  If it came from the stack or base pointer, it’s in the stack segment.  All others are in the heap.How to handle stack  The difference between the stack and the other segment is it now grows backwards (towards lower addresses).  We need more hardware support so that the hardware knows the segment grows positive or negative from the base address.  We can get the correct physical address by base address + offset - max segment size.            Segment      Base      Size (Max 4K)      Grows Positive?                  Code      32K      2K      1              Heap      34K      3K      1              Code      28K      2K      0      Segmentation presents new challenges for the OS  The segment registers must be saved and restored becase each process has its own virtual address space for context switch.  Able to update the segment size register to the new (larger/smaller) size.  Able to find physical memory space for new address spaces.  handle external fragmentation: physical memory soon fills up with pockets of free space, making it impossible to assign new segments or expand old ones."
  },
  
  {
    "title": "Why Memory Virtualisation?",
    "url": "/posts/why-memory-virtualisation/",
    "categories": "OS",
    "tags": "OS",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "  Transparency: user program dont need to worry about the physical memory address.  Protection: each process only can manipulate its own address space.",
    "content": "  Transparency: user program dont need to worry about the physical memory address.  Protection: each process only can manipulate its own address space."
  },
  
  {
    "title": "Multilevel Feedback Queue Scheduling",
    "url": "/posts/mlfq-scheduling-policy/",
    "categories": "OS",
    "tags": "OS",
    "date": "2024-01-25 00:00:00 +0800",
    





    
    "snippet": "Example RunEnter the number of processes: 3Enter duration for process 1: 10Process 1 enqueued in queue with time quantum 2Enter duration for process 2: 20Process 2 enqueued in queue with time quant...",
    "content": "Example RunEnter the number of processes: 3Enter duration for process 1: 10Process 1 enqueued in queue with time quantum 2Enter duration for process 2: 20Process 2 enqueued in queue with time quantum 2Enter duration for process 3: 30Process 3 enqueued in queue with time quantum 2Process 1 dequeued from queue with time quantum 2Process 1 is running in high priority queueProcess 1 enqueued in queue with time quantum 4Process 2 dequeued from queue with time quantum 2Process 2 is running in high priority queueProcess 2 enqueued in queue with time quantum 4Process 3 dequeued from queue with time quantum 2Process 3 is running in high priority queueProcess 3 enqueued in queue with time quantum 4Process 1 dequeued from queue with time quantum 4Process 1 is running in medium priority queueProcess 1 enqueued in queue with time quantum 8Process 2 dequeued from queue with time quantum 4Process 2 is running in medium priority queueProcess 2 enqueued in queue with time quantum 8Process 3 dequeued from queue with time quantum 4Process 3 is running in medium priority queueProcess 3 enqueued in queue with time quantum 8Process 1 dequeued from queue with time quantum 8Process 1 is running in low priority queueProcess 1 finished executionProcess 2 dequeued from queue with time quantum 8Process 2 is running in low priority queueProcess 2 enqueued in queue with time quantum 8Process 3 dequeued from queue with time quantum 8Process 3 is running in low priority queueProcess 3 enqueued in queue with time quantum 8Process 2 dequeued from queue with time quantum 8Process 2 is running in low priority queueProcess 2 finished executionProcess 3 dequeued from queue with time quantum 8Process 3 is running in low priority queueProcess 3 enqueued in queue with time quantum 8Process 3 dequeued from queue with time quantum 8Process 3 is running in low priority queueProcess 3 finished executionProcess Duration        Waiting Time    Turnaround Time1       10      12      222       20      24      443       30      30      60Example C Code#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct {  int id;  int duration;  int remaining_time;  int waiting_time;  int turnaround_time;} Process;typedef struct {  Process* processes;  int front;  int rear;  int time_quantum;} Queue;void init_queues(Queue* high_q, Queue* mid_q, Queue* low_q){  high_q-&gt;processes = malloc(10*sizeof(Process));  mid_q-&gt;processes = malloc(10*sizeof(Process));  low_q-&gt;processes = malloc(10*sizeof(Process));  high_q-&gt;time_quantum = 2;  mid_q-&gt;time_quantum = 4;  low_q-&gt;time_quantum = 8;  high_q-&gt;front = -1;  mid_q-&gt;front = -1;  low_q-&gt;front = -1;  high_q-&gt;rear = -1;  mid_q-&gt;rear = -1;  low_q-&gt;rear = -1;}void enqueue(Queue* q, Process* p){  printf(\"Process %d enqueued in queue with time quantum %d\\n\", p-&gt;id, q-&gt;time_quantum);  if(q-&gt;front &gt; 9) { return; }  q-&gt;front += 1;  q-&gt;processes[q-&gt;front].id = p-&gt;id;  q-&gt;processes[q-&gt;front].duration = p-&gt;duration;  q-&gt;processes[q-&gt;front].remaining_time = p-&gt;remaining_time;  q-&gt;processes[q-&gt;front].waiting_time = p-&gt;waiting_time;  q-&gt;processes[q-&gt;front].turnaround_time = p-&gt;turnaround_time;}Process* dequeue(Queue* q){  if(q-&gt;rear &gt;= q-&gt;front) {     q-&gt;rear = -1;    q-&gt;front = -1;    return NULL;  }  q-&gt;rear += 1;  printf(\"Process %d dequeued from queue with time quantum %d\\n\", q-&gt;processes[q-&gt;rear].id, q-&gt;time_quantum);  return &amp;q-&gt;processes[q-&gt;rear];}void mlfq(Process* processes, int n, Queue* high_q, Queue* mid_q, Queue* low_q) {  Process* current_p;  int total_turnaround_time = 0;  if (n&lt;= 0) { return; }  while(1){    current_p = dequeue(high_q);    if(current_p != NULL){      printf(\"Process %d is running in high priority queue\\n\", current_p-&gt;id);      if (current_p-&gt;duration &gt; high_q-&gt;time_quantum) {        current_p-&gt;duration -= high_q-&gt;time_quantum;        enqueue(mid_q, current_p);        total_turnaround_time += high_q-&gt;time_quantum;      } else {        total_turnaround_time += current_p-&gt;duration;        processes[current_p-&gt;id-1].turnaround_time = total_turnaround_time;        processes[current_p-&gt;id-1].waiting_time = total_turnaround_time - processes[current_p-&gt;id-1].duration;      }      continue;    }    current_p = dequeue(mid_q);    if(current_p != NULL){      printf(\"Process %d is running in medium priority queue\\n\", current_p-&gt;id);      if (current_p-&gt;duration &gt; mid_q-&gt;time_quantum) {        current_p-&gt;duration -= mid_q-&gt;time_quantum;        enqueue(low_q, current_p);        total_turnaround_time += mid_q-&gt;time_quantum;      }       else {        total_turnaround_time += current_p-&gt;duration;        processes[current_p-&gt;id-1].turnaround_time = total_turnaround_time;        processes[current_p-&gt;id-1].waiting_time = total_turnaround_time - processes[current_p-&gt;id-1].duration;        printf(\"Process %d finished execution\\n\", current_p-&gt;id);      }      continue;    }    current_p = dequeue(low_q);      if(current_p != NULL){      printf(\"Process %d is running in low priority queue\\n\", current_p-&gt;id);      if (current_p-&gt;duration &gt; low_q-&gt;time_quantum) {        current_p-&gt;duration -= low_q-&gt;time_quantum;        enqueue(low_q, current_p);        total_turnaround_time += low_q-&gt;time_quantum;      }       else {        total_turnaround_time += current_p-&gt;duration;        processes[current_p-&gt;id-1].turnaround_time = total_turnaround_time;        processes[current_p-&gt;id-1].waiting_time = total_turnaround_time - processes[current_p-&gt;id-1].duration;        printf(\"Process %d finished execution\\n\", current_p-&gt;id);      }      continue;    }    printf(\"\\n\");    break;    }}int main(){  int n;  float total_waiting_time=0, total_turnaround_time=0;  Queue* high_q = malloc(sizeof(Queue));  Queue* mid_q = malloc(sizeof(Queue));  Queue* low_q = malloc(sizeof(Queue));    printf(\"Enter the number of processes: \");  scanf(\"%d\", &amp;n);  Process* processes = malloc(n*sizeof(Process));    init_queues(high_q, mid_q, low_q);  for(int i=0;i&lt;n;i++){    processes[i].id = i+1;    printf(\"Enter duration for process %d: \", i+1);    scanf(\"%d\", &amp;processes[i].duration);    enqueue(high_q, &amp;processes[i]);  }  mlfq(processes, n, high_q, mid_q, low_q);  printf(\"Process\\tDuration\\tWaiting Time\\tTurnaround Time\\n\");  for(int i=0; i&lt;n; i++){    printf(\"%d\\t%d\\t%d\\t%d\\n\", processes[i].id, processes[i].duration, processes[i].waiting_time, processes[i].turnaround_time);    total_turnaround_time += processes[i].turnaround_time;    total_waiting_time += processes[i].waiting_time;  }  free(processes);  return 0;}"
  },
  
  {
    "title": "Welcome to Jekyll!",
    "url": "/posts/hellworld/",
    "categories": "HELLOWORLD",
    "tags": "HELLOWORLD",
    "date": "2024-01-21 00:00:00 +0800",
    





    
    "snippet": "WelcomeHello world, this is my first Jekyll blog post.I hope you like it!",
    "content": "WelcomeHello world, this is my first Jekyll blog post.I hope you like it!"
  }
  
]

